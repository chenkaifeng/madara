#-----------------1.JDBC-------------------#
jdbc.driverClass=${jdbc.driverClass.value}
#读库
jdbc.url=${jdbc.url.value}

jdbc.username=${jdbc.username.value}
jdbc.password=${jdbc.password.value}
jdbc.publickey=${jdbc.publickey.value}
#定义初始连接数
jdbc.initialSize=${jdbc.initialSize.value}
#定义最大连接数
jdbc.maxPoolSize=${jdbc.maxPoolSize.value}
#定义最小空闲
jdbc.minPoolSize=${jdbc.minPoolSize.value}
#定义最长等待时间
jdbc.maxWait=${jdbc.maxWait.value}
#timeBetweenEvictionRunsMillis毫秒秒检查一次连接池中空闲的连接,把空闲时间超过minEvictableIdleTimeMillis毫秒的连接断开,直到连接池中的连接数到minIdle为止
jdbc.timeBetweenEvictionRunsMillis=${jdbc.timeBetweenEvictionRunsMillis.value}
jdbc.minEvictableIdleTimeMillis=${jdbc.minEvictableIdleTimeMillis.value}

#-----------------2.DUBBO-------------------#
dubbo.registry.address=${dubbo.registry.address.value}
dubbo.protocol.port=${dubbo.protocol.port.value}
dubbo.protocol.threads=${dubbo.protocol.threads.value}
dubbo.cache.file=${dubbo.cache.file.value}
dubbo.consumer.timeout=${dubbo.consumer.timeout.value}
dubbo.provider.timeout=${dubbo.provider.timeout.value}
dubbo.provider.loadbalance=${dubbo.provider.loadbalance.value}

#-----------------3.日志相关配置(直接替换logback.xml，这里不生效)-------------------#
#stdout.value=${stdout.value}
file.async.value=${file.async.value}
file.error.value=${file.error.value}
file.log.value=${file.log.value}

#-----------------4.REDIS-------------------#
# redis集群模式配置
# 为防止混淆，该配置文件所有配置项前缀均应为"redis.cluster."

### ---JedisPoolConfig参数配置---
# 最大连接数(默认8)
redis.cluster.jedis.pool.maxTotal=${redis.cluster.jedis.pool.maxTotal.value}
# 最大空闲时间(默认8)
redis.cluster.jedis.pool.maxIdle=${redis.cluster.jedis.pool.maxIdle.value}
# 最小空闲时间(默认8)
redis.cluster.jedis.pool.minIdle=${redis.cluster.jedis.pool.minIdle.value}
# 每次最大连接数(默认-1)
redis.cluster.jedis.pool.numTestsPerEvictionRun=${redis.cluster.jedis.pool.numTestsPerEvictionRun.value}
# 释放扫描的扫描间隔(默认30000)
redis.cluster.jedis.pool.timeBetweenEvictionRunsMillis=${redis.cluster.jedis.pool.timeBetweenEvictionRunsMillis.value}
# 连接的最小空闲时间(默认60000)
redis.cluster.jedis.pool.minEvictableIdleTimeMillis=${redis.cluster.jedis.pool.minEvictableIdleTimeMillis.value}
# 连接空闲时间多久后释放，当空闲时间>该值且空闲连接>最大空闲连接数时直接释放(默认-1)
redis.cluster.jedis.pool.softMinEvictableIdleTimeMillis=${redis.cluster.jedis.pool.softMinEvictableIdleTimeMillis.value}
# 获得链接时的最大等待毫秒数，小于0：阻塞(默认-1)
redis.cluster.jedis.pool.maxWaitMillis=${redis.cluster.jedis.pool.maxWaitMillis.value}
# 在获得链接的时候检查有效性(默认false)
redis.cluster.jedis.pool.testOnBorrow=${redis.cluster.jedis.pool.testOnBorrow.value}
# 在空闲时检查有效性(默认true)
redis.cluster.jedis.pool.testWhileIdle=${redis.cluster.jedis.pool.testWhileIdle.value}
# 连接耗尽时是否阻塞，false报异常，true阻塞(默认true)
redis.cluster.jedis.pool.blockWhenExhausted=${redis.cluster.jedis.pool.blockWhenExhausted.value}

###---JedisConnectionFactory参数配置---
redis.cluster.jedis.connection.factory.timeout=${redis.cluster.jedis.connection.factory.timeout.value}

###---集群信息---
redis.cluster.node1.host=${redis.cluster.node1.host.value}
redis.cluster.node1.port=${redis.cluster.node1.port.value}
redis.cluster.node2.host=${redis.cluster.node2.host.value}
redis.cluster.node2.port=${redis.cluster.node2.port.value}
redis.cluster.node3.host=${redis.cluster.node3.host.value}
redis.cluster.node3.port=${redis.cluster.node3.port.value}
redis.cluster.node4.host=${redis.cluster.node4.host.value}
redis.cluster.node4.port=${redis.cluster.node4.port.value}
redis.cluster.node5.host=${redis.cluster.node5.host.value}
redis.cluster.node5.port=${redis.cluster.node5.port.value}
redis.cluster.node6.host=${redis.cluster.node6.host.value}
redis.cluster.node6.port=${redis.cluster.node6.port.value}

### ---分布式锁配置---
redis.cluster.registry.key=${redis.cluster.registry.key.value}

#-----------------6.KAFKA-------------------#
### ---KAFKA PRODUCER---
kafka.producerProperties.bootstrap.servers=${kafka.producerProperties.bootstrap.servers.value}
kafka.producerProperties.group.id=${kafka.producerProperties.group.id.value}
kafka.producerProperties.retries=${kafka.producerProperties.retries.value}
kafka.producerProperties.batch.size=${kafka.producerProperties.batch.size.value}
kafka.producerProperties.linger.ms=${kafka.producerProperties.linger.ms.value}
kafka.producerProperties.buffer.memory=${kafka.producerProperties.buffer.memory.value}

kafka.producer.defaultTopic.name=${kafka.producer.defaultTopic.name.value}

#-----------------7.MYSQL备份脚本配置-------------------#
# 全量备份脚本
mysql.backup.shell.fullbackup=${mysql.backup.shell.fullbackup.value}
# 增量备份脚本
mysql.backup.shell.incrementalbackup=${mysql.backup.shell.incrementalbackup.value}
# prepare脚本
mysql.backup.shell.prepare=${mysql.backup.shell.prepare.value}
# 数据恢复脚本
mysql.backup.shell.restore=${mysql.backup.shell.restore.value}
# 数据备份主机地址
mysql.backup.host.name=${mysql.backup.host.name.value}
# 数据备份主机用户
mysql.backup.host.user=${mysql.backup.host.user.value}
# 数据备份主机密码
mysql.backup.host.password=${mysql.backup.host.password.value}

#-----------------8.任务调度配置-------------------#
# job admin address list, such as "http://address" or "http://address01,http://address02"
job.admin.addresses=${job.admin.addresses}

# job executer address
job.executor.appname=${job.executor.appname}
job.executor.ip=${job.executor.ip}
job.executor.port=${job.executor.port}

# job log path
job.executor.logpath=${job.executor.logpath}

# access token
job.accessToken=${job.accessToken}

# job log retention days
job.executor.logretentiondays=${job.executor.logretentiondays}

#-----------------9.FTP配置-------------------#
ftp.host=${ftp.host.value}
ftp.port=${ftp.port.value}
ftp.username=${ftp.username.value}
ftp.password=${ftp.password.value}
ftp.basePath=${ftp.basePath.value}
